---
title: "Application"
author: "Erik Ortiz Covarrubias"
date: "2023-07-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```


```{r}
library(foreign)
library(xtable)
library(plm)
library(gmm)
library(readstata13)
library(lattice)
library(phtt)
library(tidyverse)
library(zoo)
library(pwt10)
library(WDI)
library(TOSTER)
library(boot)
library(readxl)

```


```{r}
set.seed(42)
```

```{r}

to_keep_acemoglu <- c("wbcode", "dem", "year", "y", "unrest")

democracy_acemoglu <- read.dta13(".\\acemoglu_democracy.dta") %>%
  select(all_of(to_keep_acemoglu))

to_keep_wdi <- c("wbcode", "year", "lifeexp")

wdi <- WDI(indicator= "SP.DYN.LE00.IN", country= "all", start=1960, end=2012) %>%
  rename(wbcode = iso3c, lifeexp = SP.DYN.LE00.IN) %>%
  select(all_of(to_keep_wdi))

keep_pwt1001 <- c("year", "countrycode", "pop", "rgdpna", "rnna", "rtfpna", "hc")
keep_pwt1001_na <- c("year", "countrycode", "q_c", "q_i", "q_g", "q_x", "q_m", "q_gdp", "q_gfcf", "xr2")
to_convert <- c("q_c", "q_i", "q_g", "q_x", "q_m", "q_gdp", "q_gfcf")


pwt <- read_xlsx(".\\pwt1001.xlsx", sheet = 3) %>% 
    subset(year >= 1960) %>% 
    select(all_of(keep_pwt1001)) %>%
    merge(
        read_xlsx(".\\pwt1001_na_data.xlsx", sheet = 3) %>%
        select(all_of(keep_pwt1001_na)) %>%
        mutate(across(all_of(to_convert), ~ . / xr2)),
    by = c("countrycode", "year")
)


pwt  <- pwt %>% 
  rename(wbcode = countrycode)

to_keep_pwt <- c("year", "pop", "wbcode", "rgdpna", "rnna", "rtfpna", "hc", "q_i", "q_g", "q_x", "q_m", "q_gfcf")

pwt <- select(pwt, all_of(to_keep_pwt))

pwt <- pwt %>%
  group_by(year) %>%
  mutate(gdp = rgdpna / pop,
         k = rnna / pop,
         i = 100* q_gfcf/ rgdpna ,
         g = 100* q_g/ rgdpna,
         x = 100* q_x/ rgdpna,
         m = 100 * q_m/ rgdpna,
         ) %>%
  ungroup()

merged_data <- merge(x = merge(pwt, democracy_acemoglu, by = c("wbcode", "year")), y = wdi, by = c("wbcode", "year"))

```



```{r}

to_keep_acemoglu <- c("wbcode", "dem", "year", "y")

democracy_acemoglu <- read.dta13(".\\acemoglu_democracy.dta") %>%
  select(all_of(to_keep_acemoglu))


keep_pwt1001 <- c("year", "countrycode", "pop", "rgdpna")


pwt <- read_xlsx(".\\pwt1001.xlsx", sheet = 3) %>% 
    subset(year >= 1960) %>% 
    select(all_of(keep_pwt1001))


pwt  <- pwt %>% 
  rename(wbcode = countrycode)

to_keep_pwt <- c("year", "pop", "wbcode", "rgdpna")

pwt <- select(pwt, all_of(to_keep_pwt))

pwt <- pwt %>%
  group_by(year) %>%
  mutate(gdp = rgdpna / pop) %>%
  ungroup()

merged_data <- merge(pwt, democracy_acemoglu, by = c("wbcode", "year"))
```


```{r}

threshold_year <- 1970

variables <- c("gdp", "dem")

complete_wbcode_dp <- merged_data %>%
  filter(year >= threshold_year) %>%
  group_by(wbcode) %>%
  filter(all(complete.cases(across(variables)))) %>%
  pull(wbcode) %>%
  unique()

length(complete_wbcode_dp)
print(complete_wbcode_dp)


complete_dta_dp <- merged_data %>%
  filter(wbcode %in% complete_wbcode_dp) %>%
  filter(year >= threshold_year)



n <- as.numeric(length(unique(complete_dta_dp$wbcode)))
T <- as.numeric(length(unique(complete_dta_dp$year)))


l.d.gdp.dy <- diff(log(matrix(complete_dta_dp$gdp, T, n)))
dem.dy <- matrix(complete_dta_dp$dem[-1], T-1, n)



```

```{r}

Eup.fit.1 <- Eup(l.d.gdp.dy ~ dem.dy + lag(l.d.gdp.dy, 1) - 1,
                 additive.effects = "twoways", dim.criterion = "PC1")

Eup.fit.2 <- Eup(l.d.gdp.dy ~ dem.dy + lag(l.d.gdp.dy, 1) + lag(l.d.gdp.dy, 2)  - 1,
                 additive.effects = "twoways", dim.criterion = "PC1")

Eup.fit.3 <- Eup(l.d.gdp.dy ~ dem.dy + lag(l.d.gdp.dy, 1) + lag(l.d.gdp.dy, 2) + lag(l.d.gdp.dy, 3) - 1,
                 additive.effects = "twoways", dim.criterion = "PC1")

Eup.fit.4 <- Eup(l.d.gdp.dy ~ dem.dy + lag(l.d.gdp.dy, 1) + lag(l.d.gdp.dy, 2) + lag(l.d.gdp.dy, 3) + lag(l.d.gdp.dy, 4) - 1,
                 additive.effects = "twoways", dim.criterion = "PC1")


Eup.sum1 <-summary(Eup.fit.1, error.type = 5)
print(Eup.sum1)


Eup.sum2 <-summary(Eup.fit.2, error.type = 5)
print(Eup.sum2)


Eup.sum3 <-summary(Eup.fit.3, error.type = 5)
print(Eup.sum3)


Eup.sum4 <-summary(Eup.fit.4, error.type = 5)
print(Eup.sum4)
plot(Eup.sum4)


```


```{r warning=FALSE}

library(boot)


# Create a list of data frames, each one representing a single country
country_list <- split(complete_dta_dp, complete_dta_dp$wbcode)

# Define a wrapper function for Eup
KSSdyWrapper <- function(data_list, indices) {
  d <- do.call(rbind, data_list[indices])
  
  l.gdp.dy <- log(matrix(d$gdp, T, n))
  dem.dy.2 <- matrix(d$dem, T, n)
  
  KSS.fit <- KSS(l.gdp.dy ~ dem.dy.2 + lag(l.gdp.dy, 1) + lag(l.gdp.dy, 2) + lag(l.gdp.dy, 3) + lag(l.gdp.dy, 4) - 1,
                 additive.effects = "twoways", factor.dim = 6, CV = TRUE)
  
  
  return(KSS.fit$slope.para)  # Return the coefficients of the Eup model
}

# Run bootstrap using boot function
boot_results_KSSdy <- boot(country_list, KSSdyWrapper, R = 1000, stype = "i")

```

```{r}

boot_results_KSSdy
plot(boot_results_KSSdy)

boot_cis <- lapply(1:5, function(i) boot.ci(boot.out = boot_results_KSSdy, index = i, type = c("norm", "perc", "bca")))

boot_cis
```

```{r}
# Load the TOSTER library
library(TOSTER)

# Set equivalence bounds
lower_bound <- -0.2
upper_bound <- 0.2

# Extract the bootstrap estimates for 'dem'
dem_bootstrap_estimates <- boot_results_KSSdy$t[, 1]

# Calculate the mean and standard deviation
mean_estimate <- mean(dem_bootstrap_estimates)
sd_estimate <- sd(dem_bootstrap_estimates)

# Perform the TOST procedure
tost_result <- TOSTone(m = mean_estimate, mu = 0, sd = sd_estimate, n = length(dem_bootstrap_estimates), low_eqbound_d = lower_bound, high_eqbound_d = upper_bound)

# Print the result
print(tost_result)
```



```{r}
threshold_year <- 1987

#variables <-c("gdp", "k", "i", "g", "x", "m", "hc", "lifeexp", "dem", "rtfpna")
variables <-c("gdp", "k", "i", "g", "x", "m", "hc", "lifeexp", "dem")

complete_wbcode <- merged_data %>%
  filter(year >= threshold_year) %>%
  group_by(wbcode) %>%
  filter(all(complete.cases(across(variables)))) %>%
  pull(wbcode) %>%
  unique()

print(complete_wbcode)
length(complete_wbcode)

merged_data_complete <- merged_data %>%
  filter(wbcode %in% complete_wbcode) %>%
  filter(year >= threshold_year)



```

```{r}
n <- as.numeric(length(unique(merged_data_complete$wbcode)))
T <- as.numeric(length(unique(merged_data_complete$year)))



l.gdp <- log(matrix(merged_data_complete$gdp, T, n))
dem <- matrix(merged_data_complete$dem, T, n)
l.capital <- log(matrix(merged_data_complete$k, T, n))
l.inv <- log(matrix(merged_data_complete$i, T, n))
l.hc <- log(matrix(merged_data_complete$hc, T, n))
l.gvt <- log(matrix(merged_data_complete$g, T, n))
l.lifeexp <- log(matrix(merged_data_complete$lifeexp, T, n))
l.trade <- log(matrix(merged_data_complete$x + merged_data_complete$m , T, n))






```


```{r}
KSS.fit <- KSS(l.gdp ~ dem +  l.inv + l.capital + l.gvt + l.hc + l.lifeexp + l.trade -1,
                 additive.effects = "twoways", CV = TRUE, consult.dim.crit = TRUE)

checkSpecif(KSS.fit, level = 0.01)
summary(KSS.fit)

plot(summary(KSS.fit))


```
```{r}

d.l.gdp <- diff(log(matrix(merged_data_complete$gdp, T, n)))
d.dem <- matrix(merged_data_complete$dem[-1], T-1, n)
d.l.capital <- diff(log(matrix(merged_data_complete$k, T, n)))
d.l.inv <- diff(log(matrix(merged_data_complete$i, T, n)))
#d.l.tfp <- diff(log(matrix(merged_data_complete$rtfpna, T, n)))
d.l.hc <- diff(log(matrix(merged_data_complete$hc, T, n)))
d.l.gvt <- diff(log(matrix(merged_data_complete$g, T, n)))
d.l.lifeexp <- diff(log(matrix(merged_data_complete$lifeexp, T, n)))
d.l.trade <- diff(log(matrix(merged_data_complete$x + merged_data_complete$m , T, n)))

```

```{r}
Eup.fit <- Eup(d.l.gdp ~  d.dem +  d.l.inv + d.l.capital + d.l.gvt + + d.l.hc + d.l.lifeexp + d.l.trade  -1,
                 additive.effects = "twoways")

checkSpecif(Eup.fit, level = 0.01)
summary(Eup.fit, error.type = 5)
plot(summary(Eup.fit, error.type = 5))

```



```{r warning=FALSE}

# Create a list of data frames, each one representing a single country
country_list <- split(merged_data_complete, merged_data_complete$wbcode)


KSSWrapper <- function(data_list, indices) {
  # Choose the data for the selected countries
  selected_data <- do.call(rbind, data_list[indices])
  
  n <- as.numeric(length(unique(selected_data$wbcode)))
  T <- as.numeric(length(unique(selected_data$year)))

  l.gdp <- log(matrix(selected_data$gdp, T, n))
  dem <- matrix(selected_data$dem, T, n)
  l.capital <- log(matrix(selected_data$k, T, n))
  l.inv <- log(matrix(selected_data$i, T, n))
  l.tfp <- log(matrix(selected_data$rtfpna, T, n))
  l.hc <- log(matrix(selected_data$hc, T, n))
  l.gvt <- log(matrix(selected_data$g, T, n))
  l.lifeexp <- log(matrix(selected_data$lifeexp, T, n))
  l.trade <- log(matrix(selected_data$x + selected_data$m , T, n))

  
  KSS.fit <- KSS(l.gdp ~ dem +l.inv + l.capital +l.gvt + l.hc + l.lifeexp + l.trade -1,
                 additive.effects = "twoways", factor.dim = 5)
  
  return(KSS.fit$slope.para)  # Return the coefficients of the Eup model
}


boot_results_KSS <- boot(country_list, KSSWrapper, R = 10000, stype = "i")

```


```{r}
boot_results_KSS

plot(boot_results_KSS)

boot_cis_KSS <- lapply(1:7, function(i) boot.ci(boot.out = boot_results_KSS, index = i, type = c("norm", "perc", "bca")))

boot_cis_KSS
```

```{r}
# Load the TOSTER library
library(TOSTER)

# Set equivalence bounds
lower_bound <- -0.2
upper_bound <- 0.2

# Extract the bootstrap estimates for 'dem'
dem_bootstrap_estimates <- boot_results_KSS$t[, 1]

# Calculate the mean and standard deviation
mean_estimate <- mean(dem_bootstrap_estimates)
sd_estimate <- sd(dem_bootstrap_estimates)

# Perform the TOST procedure
tost_result <- TOSTone(m = mean_estimate, mu = 0, sd = sd_estimate, n = length(dem_bootstrap_estimates), low_eqbound_d = lower_bound, high_eqbound_d = upper_bound)

# Print the result
print(tost_result)


```



```{r warning=FALSE}
# Define a wrapper function for Eup
EupWrapper2 <- function(data, indices) {
  d <- data[indices, ]
  
  n <- as.numeric(length(unique(d$wbcode)))
  T <- as.numeric(length(unique(d$year)))

  
  
  d.l.gdp <- diff(log(matrix(d$gdp, T, n)))
  d.dem <- matrix(d$dem[-1], T-1, n)
  d.l.capital <- diff(log(matrix(d$k, T, n)))
  d.l.inv <- diff(log(matrix(d$i, T, n)))
  #d.l.tfp <- diff(log(matrix(d$rtfpna, T, n)))
  d.l.hc <- diff(log(matrix(d$hc, T, n)))
  d.l.gvt <- diff(log(matrix(d$g, T, n)))
  d.l.lifeexp <- diff(log(matrix(d$lifeexp, T, n)))
  d.l.trade <- diff(log(matrix(d$x + d$m, T, n)))

  
  Eup.fit <- Eup(d.l.gdp ~ d.dem +  d.l.inv + d.l.capital + d.l.gvt + d.l.hc + d.l.lifeexp + d.l.trade  -1,
                 additive.effects = "twoways")
  
  Eup.fit.sum <- summary(Eup.fit, error.type = 5)
  
  return(Eup.fit.sum$coefficients[,1])  # Return the coefficients of the Eup model
}

# Run bootstrap using boot function
boot_results_Eup <- boot(merged_data_complete, EupWrapper2, R = 1000)
```

```{r}

boot_cis_Eup <- lapply(1:7, function(i) boot.ci(boot.out = boot_results_Eup, index = i, type = c("norm", "perc", "basic")))

boot_cis_Eup


boot_results_Eup


# Load the TOSTER library
library(TOSTER)

# Set equivalence bounds
lower_bound <- -0.1
upper_bound <- 0.1

# Extract the bootstrap estimates for 'dem'
dem_bootstrap_estimates <- boot_results_Eup$t[, 1]

# Calculate the mean and standard deviation
mean_estimate <- mean(dem_bootstrap_estimates)
sd_estimate <- sd(dem_bootstrap_estimates)

# Perform the TOST procedure
tost_result <- TOSTone(m = mean_estimate, mu = 0, sd = sd_estimate, n = length(dem_bootstrap_estimates), low_eqbound_d = lower_bound, high_eqbound_d = upper_bound)

# Print the result
print(tost_result)
```


