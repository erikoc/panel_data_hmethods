for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
n <- 30
T <- 12
beta <- c(0.5,0.5)
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
knitr::opts_chunk$set(echo = TRUE)
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
source("sim_final_fn.R")
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_bex <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "homo", rho = 0.5)
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_bex[[label]] <- results
}
}
}
knitr::opts_chunk$set(echo = TRUE)
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
source("sim_final_fn.R")
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_bex <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "homo", rho = 0.5)
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_bex[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_bhet <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo", rho = 0.5)
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_bhet[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_homo <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "hetero", rho = 0.5)
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_homo[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
rho <- seq(0, 1, by = 0.1)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_autocorr <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
for (i in length(rho)) {
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "autocorr", rho = rho[i] )
}
# Run the doMonteCarlo function for the current combination
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type, "_rho", i)
# Store the results in the list with the label
all_results_autocorr[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
rho <- seq(0, 1, by = 0.1)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_autocorr <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
for (i in length(rho)) {
rho <- runif(1, min = -0.3, max = 0.3)
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "autocorr", rho = rho )
}
# Run the doMonteCarlo function for the current combination
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type, "_rho", i)
# Store the results in the list with the label
all_results_autocorr[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
rho <- seq(0, 1, by = 0.1)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_autocorr <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
for (i in length(rho)) {
rho <- runif(1, min = -0.3, max = 0.3)
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "autocorr", rho = rho )
}
# Run the doMonteCarlo function for the current combination
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_autocorr[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
rho <- seq(0, 1, by = 0.1)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_autocorr_low <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
for (i in length(rho)) {
rho <- runif(1, min = -0.3, max = 0.3)
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "autocorr", rho = rho )
}
# Run the doMonteCarlo function for the current combination
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_autocorr_low[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
rho <- seq(0, 1, by = 0.1)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_autocorr_high <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
for (i in length(rho)) {
rho <- runif(1, min = 0.6, max = 0.8)
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "autocorr", rho = rho )
}
# Run the doMonteCarlo function for the current combination
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_autocorr_high[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_homo <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "hetero", rho = 0.5)
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_homo[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_homo <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "hetero", rho = 0.5)
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_homo[[label]] <- results
}
}
}
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
rho <- seq(0, 1, by = 0.1)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_autocorr_low <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
for (i in length(rho)) {
rho <- runif(1, min = -0.3, max = 0.3)
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "autocorr", rho = rho )
}
# Run the doMonteCarlo function for the current combination
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_autocorr_low[[label]] <- results
}
}
}
View(all_results_autocorr)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
rho <- seq(0, 1, by = 0.1)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Create an empty list to store the results
all_results_autocorr_high <- list()
# Iterate over the combinations of T, n, and nsim
for (T_val in T) {
for (n_val in n) {
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 500, 1000)
# Iterate over the DGP types
for (DGP_type in DGPs) {
for (i in length(rho)) {
rho <- runif(1, min = 0.6, max = 0.8)
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = FALSE, error = "autocorr", rho = rho )
}
# Run the doMonteCarlo function for the current combination
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the list with the label
all_results_autocorr_high[[label]] <- results
}
}
}
gc()
