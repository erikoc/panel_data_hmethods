stopifnot(dim(X_shifted) == c(T*n,2))
X <- shift_mean(X)
group_size <- n*T/3
colMeans(X[1:group_size,])
colMeans(X[(1 + group_size):(2*group_size),])
colMeans(X[(1+ 2*group_size):(3*group_size),])
source("sim_dgp_fn.R")
source("sim_dgp_fn.R")
n <- 30
T <- 12
beta <- c(0.5,0.5)
# 0. Generate vectors of interest
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T,n),
V6 = generate_V6(T,n))
# 0. Generate vectors of interest
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 0. Generate vectors of interest
v_lsit <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
source("sim_final_fn.R")
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
source("sim_final_fn.R")
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
source("sim_final_fn.R")
X <- generate_X(T, n)
source("sim_dgp_fn.R")
n <- 30
T <- 12
beta <- c(0.5,0.5)
X <- generate_X(T,n)
stopifnot(dim(X) == c(T*n,2))
X_shifted <- shift_mean(X)
stopifnot(dim(X_shifted) == c(T*n,2))
X <- shift_mean(X)
group_size <- n*T/3
colMeans(X[1:group_size,])
colMeans(X[(1 + group_size):(2*group_size),])
colMeans(X[(1+ 2*group_size):(3*group_size),])
# 0. Generate vectors of interest
v_list <- list()
V_list <- list(V1 = generate_V1(T, n),
V2 = generate_V2(T, n),
V3 = generate_V3(T, n),
V4 = generate_V4(T, n),
V5 = generate_V5(T, n),
V6 = generate_V6(T, n))
# 1. Perform the length and NA checks using a loop
for (i in 1:length(V_list)) {
stopifnot(length(V_list[[i]]) == T*n)
stopifnot(!anyNA(V_list[[i]]))
}
# 2. Checking that the time-varying effects are correctly specified
for (i in 1:length(V_list)) {
interval <- sample(0:(n-1), 1)
start <- interval * T + 1
end <- (interval + 1) * T
plot(1:T, V_list[[i]][start:end], type = "l", xlab = "Time", ylab = "Individual Effects",
main = paste("Individual Effects (V",i,") over Time - Interval:", interval))
}
X <- generate_X(T, n)
X <- shift_mean(X)
DGP = "K4"
# Create individual effects according to specified DGP
if (DGP == "K1") {
V <- generate_V1(T, n)
} else if (DGP == "K2") {
V <- generate_V2(T, n)
} else if (DGP == "K3") {
V <- generate_V3(T, n)
} else if (DGP == "K4") {
V <- generate_V4(T, n)
}
# Create endogenous regressors, when specified
X <- endogenous_X(T, n, X, V)
cor(X,V)
# 1. Homoskedastic
e <- generate_panel_errors(T, n, X, error = "homo")
plot(X[,2], e, type = "p", xlab = "Observation", ylab = "Error", main = "Panel Errors")
# 2. Heteroskedastic
e <- generate_panel_errors(T, n, X, error = "hetero")
plot(X[,2], e, type = "p", xlab = "Observation", ylab = "Error", main = "Panel Errors")
# 2. Autocorrelated errors
e <- generate_panel_errors(T, n, X, error = "autocorr", rho = 0.5)
plot(e[1:T], type = "l", xlab = "Observation", ylab = "Error", main = "Panel Errors")
library(plm)
n <- 30
T <- 12
beta <- c(0.5,0.5)
data <- DataGeneratingFunction(T, n, beta = beta, DGP = "K3" , endogenous = FALSE, error = "autocorr")
data_plm <- data[["plm"]]
data_Tn <-  data[["Tn"]]
KSS.fit <- KSS(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, CV = TRUE)
summary(KSS.fit)
plot(summary(KSS.fit))
Eup.fit <- Eup(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, dim.criterion = "PC3")
summary(Eup.fit)
plot(summary(Eup.fit))
plm_fit <- plm(data_plm$Y ~ data_plm$X_1 + data_plm$X_2 -1, data = data_plm,  model = "within")
summary(plm_fit)
library(plm)
n <- 30
T <- 12
beta <- c(0.5,0.5)
data <- DataGeneratingFunction(T, n, beta = beta, DGP = "E3" , endogenous = FALSE, error = "autocorr")
data_plm <- data[["plm"]]
data_Tn <-  data[["Tn"]]
KSS.fit <- KSS(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, CV = TRUE)
summary(KSS.fit)
plot(summary(KSS.fit))
Eup.fit <- Eup(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, dim.criterion = "PC3")
summary(Eup.fit)
plot(summary(Eup.fit))
plm_fit <- plm(data_plm$Y ~ data_plm$X_1 + data_plm$X_2 -1, data = data_plm,  model = "within")
summary(plm_fit)
library(plm)
n <- 30
T <- 12
beta <- c(0.5,0.5)
data <- DataGeneratingFunction(T, n, beta = beta, DGP = "E1" , endogenous = FALSE, error = "autocorr")
data_plm <- data[["plm"]]
data_Tn <-  data[["Tn"]]
KSS.fit <- KSS(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, CV = TRUE)
summary(KSS.fit)
plot(summary(KSS.fit))
Eup.fit <- Eup(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, dim.criterion = "PC3")
summary(Eup.fit)
plot(summary(Eup.fit))
plm_fit <- plm(data_plm$Y ~ data_plm$X_1 + data_plm$X_2 -1, data = data_plm,  model = "within")
summary(plm_fit)
library(plm)
n <- 30
T <- 12
beta <- c(0.5,0.5)
data <- DataGeneratingFunction(T, n, beta = beta, DGP = "E1" , endogenous = FALSE, error = "autocorr")
data_plm <- data[["plm"]]
data_Tn <-  data[["Tn"]]
KSS.fit <- KSS(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, CV = TRUE)
summary(KSS.fit)
plot(summary(KSS.fit))
Eup.fit <- Eup(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, dim.criterion = "PC3")
summary(Eup.fit)
plot(summary(Eup.fit))
plm_fit <- plm(data_plm$Y ~ data_plm$X_1 + data_plm$X_2 -1, data = data_plm,  model = "within")
summary(plm_fit)
library(plm)
n <- 30
T <- 12
beta <- c(0.5,0.5)
data <- DataGeneratingFunction(T, n, beta = beta, DGP = "B1" , endogenous = FALSE, error = "autocorr")
data_plm <- data[["plm"]]
data_Tn <-  data[["Tn"]]
KSS.fit <- KSS(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, CV = TRUE)
summary(KSS.fit)
plot(summary(KSS.fit))
Eup.fit <- Eup(data_Tn$Y ~ data_Tn$X_1 + data_Tn$X_2 -1, dim.criterion = "PC3")
summary(Eup.fit)
plot(summary(Eup.fit))
plm_fit <- plm(data_plm$Y ~ data_plm$X_1 + data_plm$X_2 -1, data = data_plm,  model = "within")
summary(plm_fit)
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Parallelized loop over T and n
all_results_bend <- foreach(T_val = T, .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
knitr::opts_chunk$set(echo = TRUE)
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
source("sim_final_fn.R")
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
beta <- c(0.5, 0.5)
results <- doMonteCarlo(10, 12, 30, beta, DGP_type, endogenous = TRUE, error = "homo")
beta <- c(0.5, 0.5)
results <- doMonteCarlo(10, 12, 30, beta, "E1", endogenous = TRUE, error = "homo")
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
# Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
## Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .export = c("v_list", "DataGeneratingFunction", "doMonteCarlo"), .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
## Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .export = c("DataGeneratingFunction", "doMonteCarlo"), .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
library(doParallel)
library(foreach)
# Register the parallel backend
n_cores <- detectCores()
registerDoParallel(cores = n_cores)
n <- c(30, 100, 300)
T <- c(12, 30)
beta <- c(0.5, 0.5)
DGPs <- c("K1", "K2", "K3", "K4", "B1", "E1")
## Start timing
timing <- system.time({
# Parallelized loop over T and n
all_results_bex <- foreach(T_val = T, .export = c("DataGeneratingFunction", "doMonteCarlo"), .combine = 'c', .multicombine = TRUE, .maxcombine = 100, .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .inorder = FALSE) %:%
foreach(n_val = n, .combine = 'c', .packages = c("mvtnorm", "matlib", "phtt", "plm", "foreach", "doParallel"), .export = c("DataGeneratingFunction", "doMonteCarlo")) %dopar% {
inner_results <- list()
# Determine the value of nsim based on the current n
nsim_val <- ifelse(n_val == 300, 50, 100)
# Loop over DGP types
for (DGP_type in DGPs) {
# Run the doMonteCarlo function for the current combination
results <- doMonteCarlo(nsim_val, T_val, n_val, beta, DGP_type, endogenous = TRUE, error = "homo")
# Create a label for the current combination
label <- paste0("T", T_val, "_n", n_val, "_nsim", nsim_val, "_", DGP_type)
# Store the results in the inner_results list with the label
inner_results[[label]] <- results
}
# Return the inner_results for this combination of T_val and n_val
return(inner_results)
}
})
source("sim_dgp_fn.R")
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
n <- 30
T <- 12
beta <- c(0.5,0.5)
nsim <- 100
results <- doMonteCarlo(nsim, T, n, beta, DGP = "K3")
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
n <- 30
T <- 12
beta <- c(0.5,0.5)
nsim <- 100
results <- doMonteCarlo(nsim, T, n, beta, DGP = "K3")
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
n <- 30
T <- 12
beta <- c(0.5,0.5)
nsim <- 100
results <- doMonteCarlo(nsim, T, n, beta, DGP = "K3")
View(results)
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
n <- 30
T <- 12
beta <- c(0.5,0.5)
nsim <- 100
results <- doMonteCarlo(nsim, T, n, beta, DGP = "K3")
View(results)
results[[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[1]][[2]]
print(results)
print(sim_results)
print(results)
source("sim_dgp_fn.R")
source("sim_montecarlo_fn.R")
n <- 30
T <- 12
beta <- c(0.5,0.5)
nsim <- 100
results <- doMonteCarlo(nsim, T, n, beta, DGP = "K3")
